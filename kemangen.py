from datetime import datetime
from pathlib import Path


def array_to_menu_string(arr):
    result = ""
    for i, char in enumerate(arr):
        result += f"{i + 1}{char} "
    return result.rstrip()


def array_to_char_string(key, arr):
    result = "'"
    for i in range(10):
        if i <= len(arr) - 1:
            result += arr[i]
            if i == len(arr) - 1:
                result += "'"
        else:
            result += f" dk({key}_err)"
    return result


def array_to_word_group(key):
    return (
        f"c *******************************************************************\n"
        f"c {key}_group handles the menu for {key}\n"
        f"group({key}_group) using keys \n"
        f"\t +any(choices) > index({key}_chars, 1) use (final)\n"
        f"\t + [K_BKSP]         > nul\n"
        f"\t nomatch            > dk({key}_err) use(final)\n"
    )


def generate_keyman(datastring, filename, version):
    basename = filename
    outputname = basename.lower().replace(" ", "_")

    char_dict = {}
    main_group = [
        "c ********************************************************************\nc main outputs the menus, and handles any other normal key processing\ngroup(main) using keys"]
    first_group = [
        "c *******************************************************************\nc first matches a menu in the context or passes processing to main\ngroup(first)"]
    menu_store = ["c menu stores"]
    character_store = ["", "c character choice stores - error deadkeys are used to pad",
                       "c out the stores so they are the same length as the choices store"]
    word_group = []
    error_menu = [
        "c *******************************************************************\nc final matches error markers and finishes processing\ngroup(final)"]

    header = f"""c {outputname} generated by KeymanGen (@Nulpoints) at {datetime.now()}
c with name "{basename}"
store(&VERSION) '10.0'
store(&NAME) '{basename}'
store(&COPYRIGHT) 'Â© Nulpoints'
store(&KEYBOARDVERSION) '{version}'
store(&TARGETS) 'any'

begin Unicode > use(first)
c used to store numbers for 10 possible choices in a menu
store(choices) '1234567890'"""
    data = datastring
    data = data.replace('\r', '')
    data = data.split('\n')

    for row in data:
        row = row.split(',')
        word = row[0].strip("'")

        # if len(word) == 1:
        #     word = f"'{word}' + ' '"
        # else:
        #     word = f"'{word[:-1]}' + '{word[-1]}'"
        uni = row[1]

        if word[-1].isnumeric():
            try:
                char_dict[word[:-1]]['chars'].append(uni)
            except:
                char_dict[word[:-1]]['chars'] = [uni]
        else:
            char_dict.update({word: {'chars': [uni]}})

        if word[-1].isnumeric():
            word = word[:-1]
        if len(row) > 2:
            char_dict[word]['type'] = row[2]
        else:
            char_dict[word]['type'] = 'word'

    for key in char_dict:
        if len(char_dict[key]['chars']) == 1:
            if char_dict[key]['type'] == 'punctuation':
                main_group.append(f"+ '{key}' > '{''.join(char_dict[key]['chars'])}'")
            # Print Character that has only one form
            elif char_dict[key]['type'] == 'letter':
                main_group.append(f"+ '{key}' > '{''.join(char_dict[key]['chars'])}'")
            else:
                main_group.append(f"'{key}' + ' ' > '{''.join(char_dict[key]['chars'])}'")
        else:
            # Add menu line to main group
            if char_dict[key]['type'] == 'punctuation':
                main_group.append(f"+ '{key}' > outs({key}_menu)")
            elif char_dict[key]['type'] == 'letter':
                main_group.append(f"+ '{key}' > outs({key}_menu)")
            else:
                main_group.append(f"'{key}' + ' ' > outs({key}_menu)")
            # Add menu line to menu_store
            menu_store.append(f"store({key}_menu) '[{array_to_menu_string(char_dict[key]['chars'])}]'")
            # Add Character Store Line
            character_store.append(f"store({key}_chars) {array_to_char_string(key, char_dict[key]['chars'])}")
            # Add to First Group
            first_group.append(f"outs({key}_menu) > use({key}_group)")
            # Add to Word Group
            word_group.append(array_to_word_group(key))
            error_menu.append(f"dk({key}_err) > beep outs({key}_menu)")

    first_group.append("nomatch > use(main)")
    return (header +
                "\n" +
                "\n".join(menu_store) +
                "\n" +
                "\n".join(character_store) +
                "\n" +
                "\n\t".join(first_group) +
                "\n" +
                "\n\t".join(main_group) +
                "\n" +
                "\n\t".join(error_menu) +
                "\n" +
                "\n".join(word_group))
